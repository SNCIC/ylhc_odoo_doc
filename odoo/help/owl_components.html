<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Odoo 18 Owl组件参考文档</title>
    <link rel="stylesheet" href="../../css/docs.css">
</head>
<body>
    <h1>Owl组件</h1>
    
    <h2>概述</h2>
    <p>Odoo JavaScript框架使用一个名为Owl的自定义组件框架。它是一个声明式组件系统，灵感源自Vue和React。组件使用QWeb模板定义，并通过一些Owl特定的指令进行增强。<a href="https://github.com/odoo/owl">Owl官方文档</a>包含完整的参考手册和教程。</p>
    
    <div class="note important">
        <p>虽然Owl代码可以在<code>web</code>模块中找到，但它是从单独的GitHub存储库维护的。任何对Owl的修改都应该通过在<a href="https://github.com/odoo/owl">https://github.com/odoo/owl</a>上提交拉取请求来进行。</p>
    </div>
    
    <div class="note">
        <p>目前，所有Odoo版本（从14版本开始）共享相同的Owl版本。</p>
    </div>
    
    <h2>使用Owl组件</h2>
    <p>Owl文档已经详细说明了Owl框架，所以本页只提供Odoo特定的信息。首先，让我们看看如何在Odoo中创建一个简单的组件。</p>
    
    <div class="code-block">
        <pre><code>import { Component, xml, useState } from "@odoo/owl";

class MyComponent extends Component {
    static template = xml`
        &lt;div t-on-click="increment"&gt;
            &lt;t t-esc="state.value"&gt;
        &lt;/div&gt;
    `;

    setup() {
        this.state = useState({ value: 1 });
    }

    increment() {
        this.state.value++;
    }
}</code></pre>
    </div>
    
    <p>这个例子显示了Owl作为库在全局命名空间<code>@odoo/owl</code>中可用：它可以像Odoo中的大多数库一样简单地使用。注意，我们在这里将模板定义为静态属性，但没有使用<code>static</code>关键字，这在某些浏览器中可能不可用（Odoo JavaScript代码应符合ECMAScript 2019标准）。</p>
    
    <p>我们在这里使用<code>xml</code>助手在JavaScript代码中定义模板。但这只适用于入门。在实际应用中，Odoo中的模板应该在XML文件中定义，以便它们可以被翻译。在这种情况下，组件应该只定义模板名称。</p>
    
    <p>在实践中，大多数组件应该定义2或3个文件，位于同一位置：JavaScript文件（<code>my_component.js</code>）、模板文件（<code>my_component.xml</code>）和可选的scss（或css）文件（<code>my_component.scss</code>）。这些文件应该被添加到某些资产包中。Web框架将负责加载JavaScript/CSS文件，并将模板加载到Owl中。</p>
    
    <p>以下是上述组件应该如何定义：</p>
    
    <div class="code-block">
        <pre><code>import { Component, useState } from "@odoo/owl";

class MyComponent extends Component {
    static template = 'myaddon.MyComponent';

    ...
}</code></pre>
    </div>
    
    <p>而模板现在位于相应的XML文件中：</p>
    
    <div class="code-block">
        <pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;templates xml:space="preserve"&gt;

&lt;t t-name="myaddon.MyComponent"&gt;
  &lt;div t-on-click="increment"&gt;
    &lt;t t-esc="state.value"/&gt;
  &lt;/div&gt;
&lt;/t&gt;

&lt;/templates&gt;</code></pre>
    </div>
    
    <div class="note">
        <p>模板名称应该遵循约定<code>addon_name.ComponentName</code>。</p>
    </div>
    
    <p>参见</p>
    <ul>
        <li><a href="https://github.com/odoo/owl">Owl仓库</a></li>
    </ul>
    
    <h2>最佳实践</h2>
    <p>首先，组件是类，所以它们有一个构造函数。但是构造函数是JavaScript中的特殊方法，无法以任何方式覆盖。由于这在Odoo中是一个偶尔有用的模式，我们需要确保Odoo中的组件不直接使用构造函数方法。相反，组件应该使用<code>setup</code>方法：</p>
    
    <div class="code-block">
        <pre><code>// 正确做法:
class MyComponent extends Component {
    setup() {
        // 在这里初始化组件
    }
}

// 错误做法. 不要这样做!
class IncorrectComponent extends Component {
    constructor(parent, props) {
        // 在这里初始化组件
    }
}</code></pre>
    </div>
    
    <p>另一个好的做法是对模板名称使用一致的约定：<code>addon_name.ComponentName</code>。这可以防止Odoo插件之间的名称冲突。</p>
    
    <h2>组件参考列表</h2>
    <p>Odoo Web客户端是用Owl组件构建的。为了更容易，Odoo JavaScript框架提供了一套可以在一些常见情况下重用的通用组件，如下拉菜单、复选框或日期选择器。本页解释了如何使用这些通用组件。</p>
    
    <table>
        <tr>
            <th>技术名称</th>
            <th>简短描述</th>
        </tr>
        <tr>
            <td><a href="#frontend-owl-actionswiper">ActionSwiper</a></td>
            <td>一个可以在触摸滑动时执行操作的滑动组件</td>
        </tr>
        <tr>
            <td><a href="#frontend-owl-checkbox">CheckBox</a></td>
            <td>一个简单的复选框组件，旁边有标签</td>
        </tr>
        <tr>
            <td><a href="#frontend-owl-colorlist">ColorList</a></td>
            <td>一个可供选择的颜色列表</td>
        </tr>
        <tr>
            <td><a href="#frontend-owl-dropdown">Dropdown</a></td>
            <td>功能齐全的下拉菜单</td>
        </tr>
        <tr>
            <td><a href="#frontend-owl-notebook">Notebook</a></td>
            <td>一个使用标签导航多个页面的组件</td>
        </tr>
        <tr>
            <td><a href="#frontend-pager">Pager</a></td>
            <td>一个处理分页的小组件</td>
        </tr>
        <tr>
            <td><a href="#frontend-select-menu">SelectMenu</a></td>
            <td>一个用于在不同选项之间选择的下拉组件</td>
        </tr>
        <tr>
            <td><a href="#frontend-tags-list">TagsList</a></td>
            <td>一个以圆形标签显示的标签列表</td>
        </tr>
    </table>
    
    <h3 id="frontend-owl-actionswiper">ActionSwiper</h3>
    <h4>位置</h4>
    <p><code>@web/core/action_swiper/action_swiper</code></p>
    
    <h4>描述</h4>
    <p>这是一个可以在水平滑动元素时执行操作的组件。滑动器包裹目标元素以为其添加操作。当用户释放超过其宽度一定比例的滑动器时，执行操作。</p>
    
    <div class="code-block">
        <pre><code>&lt;ActionSwiper onLeftSwipe="Object" onRightSwipe="Object"&gt;
  &lt;SomeElement/&gt;
&lt;/ActionSwiper&gt;</code></pre>
    </div>
    
    <p>使用这个组件最简单的方法是如上所示，直接在XML模板中将它包围在目标元素周围。但有时，您可能想要扩展现有元素的行为，而不想复制模板。这也是可以做到的。</p>
    
    <p>如果您想扩展现有元素的行为，您必须通过直接包装它来放置元素。此外，您可以有条件地添加props来管理元素何时可滑动、其动画和执行操作所需的最小滑动比例。</p>
    
    <p>您可以使用此组件轻松地与记录、消息、列表中的项目等进行交互。</p>
    
    <div class="image-example">
        <div class="image-title">ActionSwiper使用示例</div>
    </div>
    
    <p>以下示例创建了一个基本的ActionSwiper组件。在这里，两个方向的滑动都已启用。</p>
    
    <div class="code-block">
        <pre><code>&lt;ActionSwiper
  onRightSwipe="
    {
      action: '() => Delete item',
      icon: 'fa-delete',
      bgColor: 'bg-danger',
    }"
  onLeftSwipe="
    {
      action: '() => Star item',
      icon: 'fa-star',
      bgColor: 'bg-warning',
    }"
&gt;
  &lt;div&gt;
    可滑动项目
  &lt;/div&gt;
&lt;/ActionSwiper&gt;</code></pre>
    </div>
    
    <div class="note">
        <p>使用从右到左（RTL）语言时，操作会被置换。</p>
    </div>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>animationOnMove</td>
            <td>Boolean</td>
            <td>可选布尔值，用于确定滑动期间是否存在平移效果</td>
        </tr>
        <tr>
            <td>animationType</td>
            <td>String</td>
            <td>滑动结束后使用的可选动画（bounce或forwards）</td>
        </tr>
        <tr>
            <td>onLeftSwipe</td>
            <td>Object</td>
            <td>如果存在，actionswiper可以向左滑动</td>
        </tr>
        <tr>
            <td>onRightSwipe</td>
            <td>Object</td>
            <td>如果存在，actionswiper可以向右滑动</td>
        </tr>
        <tr>
            <td>swipeDistanceRatio</td>
            <td>Number</td>
            <td>执行操作必须滑动的可选最小宽度比率</td>
        </tr>
    </table>
    
    <p>您可以同时使用<code>onLeftSwipe</code>和<code>onRightSwipe</code> props。</p>
    
    <p>用于左/右滑动的<code>Object</code>必须包含：</p>
    <ul>
        <li><code>action</code>，是作为回调的可调用<code>Function</code>。一旦在给定方向完成滑动，就会执行该操作。</li>
        <li><code>icon</code>是要使用的图标类，通常用于表示操作。它必须是一个<code>string</code>。</li>
        <li><code>bgColor</code>是背景颜色，用于装饰操作。可以是以下Bootstrap上下文颜色之一（<code>danger</code>、<code>info</code>、<code>secondary</code>、<code>success</code>或<code>warning</code>）。</li>
    </ul>
    <p>必须提供这些值来定义滑动器的行为和视觉外观。</p>
    
    <h4>示例：扩展现有组件</h4>
    <p>在以下示例中，您可以使用<code>xpath</code>将现有元素包装在ActionSwiper组件中。在这里，添加了一个滑动器，用于将邮件标记为已读。</p>
    
    <div class="code-block">
        <pre><code>&lt;xpath expr="//*[hasclass('o_Message')]" position="after"&gt;
  &lt;ActionSwiper
    onRightSwipe="messaging.device.isMobile and messageView.message.isNeedaction ?
      {
        action: () => messageView.message.markAsRead(),
        icon: 'fa-check-circle',
        bgColor: 'bg-success',
      } : undefined"
  /&gt;
&lt;/xpath&gt;
&lt;xpath expr="//ActionSwiper" position="inside"&gt;
  &lt;xpath expr="//*[hasclass('o_Message')]" position="move"/&gt;
&lt;/xpath&gt;</code></pre>
    </div>
    
    <h3 id="frontend-owl-checkbox">CheckBox</h3>
    <h4>位置</h4>
    <p><code>@web/core/checkbox/checkbox</code></p>
    
    <h4>描述</h4>
    <p>这是一个简单的复选框组件，旁边有标签。复选框与标签相关联：每当点击标签时，复选框都会切换状态。</p>
    
    <div class="code-block">
        <pre><code>&lt;CheckBox value="boolean" disabled="boolean" t-on-change="onValueChange"&gt;
  一些文本
&lt;/CheckBox&gt;</code></pre>
    </div>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>value</td>
            <td>boolean</td>
            <td>如果为true，复选框将被选中，否则不选中</td>
        </tr>
        <tr>
            <td>disabled</td>
            <td>boolean</td>
            <td>如果为true，复选框将被禁用，否则启用</td>
        </tr>
    </table>
    
    <h3 id="frontend-owl-colorlist">ColorList</h3>
    <h4>位置</h4>
    <p><code>@web/core/colorlist/colorlist</code></p>
    
    <h4>描述</h4>
    <p>ColorList可以让您从预定义列表中选择一种颜色。默认情况下，该组件显示当前选择的颜色，在<code>canToggle</code> props出现之前不可展开。不同的props可以改变其行为，以始终展开列表，或使其在点击时作为切换器，显示可用颜色列表，直到选择一个选项。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>canToggle</td>
            <td>boolean</td>
            <td>可选。colorlist是否可以在点击时展开列表</td>
        </tr>
        <tr>
            <td>colors</td>
            <td>array</td>
            <td>在组件中显示的颜色列表。每种颜色都有一个唯一ID</td>
        </tr>
        <tr>
            <td>forceExpanded</td>
            <td>boolean</td>
            <td>可选。如果为true，列表始终展开</td>
        </tr>
        <tr>
            <td>isExpanded</td>
            <td>boolean</td>
            <td>可选。如果为true，列表默认展开</td>
        </tr>
        <tr>
            <td>onColorSelected</td>
            <td>function</td>
            <td>选择颜色后执行的回调</td>
        </tr>
        <tr>
            <td>selectedColor</td>
            <td>number</td>
            <td>可选。被选中的颜色ID</td>
        </tr>
    </table>
    
    <p>颜色<code>id</code>如下：</p>
    <table>
        <tr>
            <th>Id</th>
            <th>颜色</th>
        </tr>
        <tr>
            <td>0</td>
            <td>无颜色</td>
        </tr>
        <tr>
            <td>1</td>
            <td>红色</td>
        </tr>
        <tr>
            <td>2</td>
            <td>橙色</td>
        </tr>
        <tr>
            <td>3</td>
            <td>黄色</td>
        </tr>
        <tr>
            <td>4</td>
            <td>浅蓝色</td>
        </tr>
        <tr>
            <td>5</td>
            <td>深紫色</td>
        </tr>
        <tr>
            <td>6</td>
            <td>鲑鱼粉色</td>
        </tr>
        <tr>
            <td>7</td>
            <td>中蓝色</td>
        </tr>
        <tr>
            <td>8</td>
            <td>深蓝色</td>
        </tr>
        <tr>
            <td>9</td>
            <td>紫红色</td>
        </tr>
        <tr>
            <td>12</td>
            <td>绿色</td>
        </tr>
        <tr>
            <td>11</td>
            <td>紫色</td>
        </tr>
    </table>
    
    <h3 id="frontend-owl-dropdown">Dropdown</h3>
    <h4>位置</h4>
    <p><code>@web/core/dropdown/dropdown</code>和<code>@web/core/dropdown/dropdown_item</code></p>
    
    <h4>描述</h4>
    <p>Dropdown组件允许您在点击切换按钮时显示一个项目列表菜单。可以与DropdownItems结合使用，在选择项目时调用回调并关闭菜单。</p>
    
    <p>下拉菜单是令人惊讶的复杂组件，它们提供的功能列表如下：</p>
    <ul>
        <li>点击时切换项目列表</li>
        <li>点击外部时关闭</li>
        <li>选择项目时调用函数</li>
        <li>选择项目时可选择是否关闭项目列表</li>
        <li>SIY：自己设计样式</li>
        <li>支持子下拉菜单，可达任意级别</li>
        <li>可配置热键，用于打开/关闭下拉菜单或选择下拉菜单项</li>
        <li>键盘导航（箭头、tab、shift+tab、home、end、enter和escape）</li>
        <li>当页面滚动或调整大小时重新定位自身</li>
        <li>智能选择打开方向（自动处理从右到左的方向）</li>
        <li>直接兄弟下拉菜单：当一个打开时，在悬停时切换其他</li>
    </ul>
    
    <p>要正确使用<code>&lt;Dropdown/&gt;</code>组件，您需要填充两个OWL插槽：</p>
    <ul>
        <li><code>default</code>插槽：它包含下拉菜单的<em>切换</em>元素。默认情况下，点击事件将附加到该元素上以打开和关闭下拉菜单。</li>
        <li><code>content</code>插槽：它包含下拉菜单本身的<em>元素</em>，并在弹出窗口内渲染。虽然不是必需的，但通常会在此插槽中放置一些<code>DropdownItem</code>，当选择这些项目时，下拉菜单会自动关闭。</li>
    </ul>
    
    <div class="code-block">
        <pre><code>&lt;Dropdown&gt;
  &lt;!-- "default"插槽的内容是组件的切换器 --&gt;
  &lt;button class="my-btn" type="button"&gt;
    点击我切换下拉菜单！
  &lt;/button&gt;

  &lt;!-- "content"插槽在切换器旁边弹出的菜单内渲染 --&gt;
  &lt;t t-set-slot="content"&gt;
    &lt;DropdownItem onSelected="selectItem1"&gt;菜单项1&lt;/DropdownItem&gt;
    &lt;DropdownItem onSelected="selectItem2"&gt;菜单项2&lt;/DropdownItem&gt;
  &lt;/t&gt;
&lt;/Dropdown&gt;</code></pre>
    </div>
    
    <h4>Dropdown Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>menuClass</td>
            <td>String</td>
            <td>可选，添加到下拉菜单的类名</td>
        </tr>
        <tr>
            <td>disabled</td>
            <td>Boolean</td>
            <td>可选，如果为true，禁用下拉菜单，用户无法再打开它（默认：false）</td>
        </tr>
        <tr>
            <td>items</td>
            <td>Array</td>
            <td>可选，要在下拉菜单内显示为DropdownItems的项目列表</td>
        </tr>
        <tr>
            <td>position</td>
            <td>String</td>
            <td>可选定义所需的菜单打开位置。自动应用RTL方向。应该是有效的<a href="hooks.html#frontend-hooks-useposition">usePosition</a>钩子位置（默认：bottom-start）</td>
        </tr>
        <tr>
            <td>beforeOpen</td>
            <td>Function</td>
            <td>可选，在打开前调用的函数。可能是异步的。</td>
        </tr>
        <tr>
            <td>onOpened</td>
            <td>Function</td>
            <td>可选，打开后调用的函数。</td>
        </tr>
        <tr>
            <td>onStateChanged</td>
            <td>Function</td>
            <td>可选，在打开或关闭后调用的函数（给出一个布尔值作为单个参数，表示下拉菜单是打开还是关闭）。</td>
        </tr>
        <tr>
            <td>state</td>
            <td>Object</td>
            <td>可选，具有open()、close()和isOpen属性的对象，用于手动控制下拉菜单何时打开和关闭。</td>
        </tr>
        <tr>
            <td>manual</td>
            <td>Boolean</td>
            <td>可选，为true时，Dropdown组件不会向切换器添加点击事件监听器。这允许更好地控制何时打开下拉菜单。（这应与state prop一起使用）</td>
        </tr>
        <tr>
            <td>navigationOptions</td>
            <td>Boolean</td>
            <td>可选，覆盖下拉菜单的导航选项（参见web/core/navigation/navigation）。</td>
        </tr>
        <tr>
            <td>holdOnHover</td>
            <td>Boolean</td>
            <td>可选，如果为true，在鼠标悬停时保持下拉菜单在同一位置，当菜单内容变化时创建更好的用户体验。</td>
        </tr>
        <tr>
            <td>menuRef</td>
            <td>Function</td>
            <td>可选，允许获取下拉菜单的引用（需要从useChildRef返回的函数）</td>
        </tr>
    </table>
    
    <h4>DropdownItem Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>class</td>
            <td>String或Object</td>
            <td>可选值，添加到根span类名（支持字符串和<a href="https://github.com/odoo/owl/blob/master/doc/reference/templates.md#dynamic-class-attribute">OWL类名对象符号</a>）。</td>
        </tr>
        <tr>
            <td>onSelected</td>
            <td>Function</td>
            <td>可选，选择下拉项时调用的函数。</td>
        </tr>
        <tr>
            <td>closingMode</td>
            <td>"none" | "closest" | "all"</td>
            <td>可选，控制选择项目时应关闭哪个父下拉菜单：none：下拉菜单不会关闭，closest：直接父级将关闭，all：每个嵌套的父下拉菜单都将关闭（默认：all）</td>
        </tr>
        <tr>
            <td>attrs</td>
            <td>Object</td>
            <td>可选对象，表示要添加到根元素的属性。<code>&lt;DropdownItem attrs="{ title: 'A tooltip', 'data-hotkey': 'shift+a' }"&gt;</code>。（如果设置了href，元素将自动成为a元素）。</td>
        </tr>
    </table>
    
    <div class="note important">
        <p>编写组件的自定义CSS时，不要忘记菜单元素不在切换器旁边，而是在文档底部的覆盖容器内。因此，使用<code>menuClass</code>和<code>class</code> props可以更轻松地编写选择器。（这种DOM魔术让我们避免了许多z-index问题。）</p>
    </div>
    
    <h4>嵌套下拉菜单</h4>
    <p>下拉菜单可以嵌套，要做到这一点，只需将新的Dropdown组件放入其他下拉菜单的content插槽中。当父下拉菜单打开时，子下拉菜单将在悬停时自动打开。</p>
    
    <p>默认情况下，选择DropdownItem将关闭整个Dropdown树。</p>
    
    <p>示例</p>
    <p>此示例显示了如何创建一个嵌套的File下拉菜单，New子元素的子菜单。</p>
    
    <div class="code-block">
        <pre><code>&lt;Dropdown&gt;
  &lt;button&gt;文件&lt;/button&gt;
  &lt;t t-set-slot="content"&gt;
    &lt;DropdownItem onSelected="() => this.onItemSelected('file-save')"&gt;保存&lt;/DropdownItem&gt;
    &lt;DropdownItem onSelected="() => this.onItemSelected('file-open')"&gt;打开&lt;/DropdownItem&gt;

    &lt;Dropdown&gt;
      &lt;button&gt;新建&lt;/button&gt;
      &lt;t t-set-slot="content"&gt;
        &lt;DropdownItem onSelected="() => this.onItemSelected('file-new-document')"&gt;文档&lt;/DropdownItem&gt;
        &lt;DropdownItem onSelected="() => this.onItemSelected('file-new-spreadsheet')"&gt;电子表格&lt;/DropdownItem&gt;
      &lt;/t&gt;
    &lt;/Dropdown&gt;
  &lt;/t&gt;
&lt;/Dropdown&gt;</code></pre>
    </div>
    
    <p>在下面的示例中，我们递归调用模板来显示树状结构。</p>
    
    <div class="code-block">
        <pre><code>&lt;t t-name="addon.MainTemplate"&gt;
  &lt;div&gt;
    &lt;t t-call="addon.RecursiveDropdown"&gt;
      &lt;t t-set="name" t-value="'主菜单'" /&gt;
      &lt;t t-set="items" t-value="state.menuItems" /&gt;
    &lt;/t&gt;
  &lt;/div&gt;
&lt;/t&gt;

&lt;t t-name="addon.RecursiveDropdown"&gt;
  &lt;Dropdown&gt;
    &lt;button t-esc="name"&gt;&lt;/button&gt;
    &lt;t t-set-slot="content"&gt;
      &lt;t t-foreach="items" t-as="item" t-key="item.id"&gt;

        &lt;!-- 如果此项目没有子项：使其成为&lt;DropdownItem/&gt; --&gt;
        &lt;DropdownItem t-if="!item.childrenTree.length" onSelected="() => this.onItemSelected(item)" t-esc="item.name"/&gt;

        &lt;!-- 否则：递归调用当前下拉菜单模板 --&gt;
        &lt;t t-else="" t-call="addon.RecursiveDropdown"&gt;
          &lt;t t-set="name" t-value="item.name" /&gt;
          &lt;t t-set="items" t-value="item.childrenTree" /&gt;
        &lt;/t&gt;
      &lt;/t&gt;
    &lt;/t&gt;
  &lt;/Dropdown&gt;
&lt;/t&gt;</code></pre>
    </div>
    
    <h4>受控下拉菜单</h4>
    <p>如果需要，您还可以使用代码打开或关闭下拉菜单。要做到这一点，您必须使用<code>useDropdownState</code>钩子以及<code>state</code> prop。<code>useDropdownState</code>返回一个具有<code>open</code>和<code>close</code>方法（以及<code>isOpen</code> getter）的对象。将该对象提供给要控制的下拉菜单的<code>state</code> prop，并调用相应的函数就可以打开和关闭您的下拉菜单。</p>
    
    <p>如果不希望在切换器上添加默认点击处理程序，也可以将<code>manual</code>设置为<code>true</code>。</p>
    
    <p>示例</p>
    <p>以下示例显示了一个在挂载时自动打开的下拉菜单，点击内部按钮只有50%的几率关闭。</p>
    
    <div class="code-block">
        <pre><code>import { Component, onMounted } from "@odoo/owl";
import { Dropdown } from "@web/core/dropdown/dropdown";
import { DropdownItem } from "@web/core/dropdown/dropdown_item";
import { useDropdownState } from "@web/core/dropdown/dropdown_hooks";

class MyComponent extends Component {

  static components = { Dropdown, DropdownItem };
  static template = xml`
    &lt;Dropdown state="this.dropdown"&gt;
      &lt;div&gt;我的下拉菜单&lt;/div&gt;

      &lt;t t-set-slot="content"&gt;
        &lt;button t-on-click="() => this.mightClose()"&gt;关闭它！&lt;button&gt;
      &lt;/t&gt;
    &lt;/Dropdown&gt;
  `;

  setup() {
    this.dropdown = useDropdownState();

    onMounted(() => {
      this.dropdown.open();
    });
  }

  mightClose() {
    if (Math.random() > 0.5) {
      this.dropdown.close();
    }
  }
}</code></pre>
    </div>
    
    <h4>DropdownGroup</h4>
    <p><strong>位置：</strong><code>@web/core/dropdown/dropdown_group</code></p>
    
    <p>您可以使用DropdownGroup组件使Dropdowns共享一个通用组，这意味着当其中一个Dropdown打开时，其他Dropdown将自动在鼠标悬停时打开自己，无需点击。</p>
    
    <p>要做到这一点，可以用单个DropdownGroup包围所有Dropdowns，或者用具有相同<code>group</code>键的DropdownGroups包围它们。</p>
    
    <p>示例</p>
    <p>在下面的示例中，片段中的所有下拉菜单将共享相同的组：</p>
    
    <div class="code-block">
        <pre><code>&lt;DropdownGroup&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
&lt;/DropdownGroup&gt;</code></pre>
    </div>
    
    <p>而在以下代码段中，只有第一个、第二个和第四个下拉菜单共享相同的组：</p>
    
    <div class="code-block">
        <pre><code>&lt;DropdownGroup group="'my-group'"&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
&lt;/DropdownGroup&gt;

&lt;DropdownGroup group="'my-other-group'"&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
&lt;/DropdownGroup&gt;

&lt;DropdownGroup group="'my-group'"&gt;
  &lt;Dropdown&gt;...&lt;/Dropdown&gt;
&lt;/DropdownGroup&gt;</code></pre>
    </div>
    
    <h3 id="frontend-owl-notebook">Notebook</h3>
    <h4>位置</h4>
    <p><code>@web/core/notebook/notebook</code></p>
    
    <h4>描述</h4>
    <p>Notebook用于在标签式界面中显示多个页面。标签可以位于元素顶部以水平显示，或者位于左侧以垂直布局。</p>
    
    <p>有两种方法可以定义要实例化的Notebook页面，一种是使用<code>slot</code>，另一种是传递专用的<code>props</code>。</p>
    
    <p>可以使用<code>isDisabled</code>属性禁用页面，直接在插槽节点上设置，或者在页面声明中设置（如果Notebook使用props给出的<code>pages</code>）。禁用后，相应的标签会变灰并设置为非活动状态。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>anchors</td>
            <td>object</td>
            <td>可选。允许锚点导航到不可见标签中的元素。</td>
        </tr>
        <tr>
            <td>className</td>
            <td>string</td>
            <td>可选。设置在组件根部的类名。</td>
        </tr>
        <tr>
            <td>defaultPage</td>
            <td>string</td>
            <td>可选。默认显示的页面ID。</td>
        </tr>
        <tr>
            <td>icons</td>
            <td>array</td>
            <td>可选。标签中使用的图标列表。</td>
        </tr>
        <tr>
            <td>orientation</td>
            <td>string</td>
            <td>可选。标签方向是水平还是垂直。</td>
        </tr>
        <tr>
            <td>onPageUpdate</td>
            <td>function</td>
            <td>可选。页面更改后执行的回调。</td>
        </tr>
        <tr>
            <td>pages</td>
            <td>array</td>
            <td>可选。包含从模板填充的页面列表。</td>
        </tr>
    </table>
    
    <p>示例</p>
    <blockquote>
        <p>第一种方法是在组件的插槽中设置页面。</p>
        <div class="code-block">
            <pre><code>&lt;Notebook orientation="'vertical'"&gt;
 &lt;t t-set-slot="page_1" title="'页面1'" isVisible="true"&gt;
   &lt;h1&gt;我的第一个页面&lt;/h1&gt;
   &lt;p&gt;现在是构建Owl组件的时候了。你阅读过文档吗？&lt;/p&gt;
 &lt;/t&gt;
 &lt;t t-set-slot="page_2" title="'第二页'" isVisible="true"&gt;
   &lt;p&gt;智慧猫头鹰的无声飞行。通过月光照射的深林，指引我编码的路径&lt;/p&gt;
 &lt;/t&gt;
&lt;/Notebook&gt;</code></pre>
        </div>
        <p>定义页面的另一种方法是通过传递props。如果一些页面共享相同的结构，这可能会很有用。首先为您可能使用的每个页面模板创建一个组件。</p>
        <div class="code-block">
            <pre><code>import { Component, xml } from "@odoo/owl";
import { Notebook } from "@web/core/notebook/notebook";

class MyTemplateComponent extends Component {
 static template = xml`
   &lt;h1 t-esc="props.title" /&gt;
   &lt;p t-esc="props.text" /&gt;
 `;
}

class MyComponent extends Component {
 static template = xml`
   &lt;Notebook defaultPage="'page_2'" pages="pages" /&gt;
 `;

 get pages() {
   return [
     {
       Component: MyTemplateComponent,
       title: "页面1",
       props: {
         title: "我的第一个页面",
         text: "这个页面不可见",
       },
     },
     {
       Component: MyTemplateComponent,
       id: "page_2",
       title: "页面2",
       props: {
         title: "我的第二个页面",
         text: "你在正确的地方！",
       },
     },
   ]
 }
}</code></pre>
        </div>
    </blockquote>
    
    <p>两个示例如下所示：</p>
    <div class="image-example">
        <div class="image-title">垂直和水平布局的示例</div>
    </div>
    
    <h3 id="frontend-pager">Pager</h3>
    <h4>位置</h4>
    <p><code>@web/core/pager/pager</code></p>
    
    <h4>描述</h4>
    <p>Pager是一个用于处理分页的小组件。页面由<code>offset</code>和<code>limit</code>（页面大小）定义。它显示当前页面和元素的<code>total</code>数量，例如，"9-12 / 20"。在上一个例子中，<code>offset</code>是8，<code>limit</code>是4，<code>total</code>是20。它有两个按钮（"上一页"和"下一页"）用于在页面之间导航。</p>
    
    <div class="note">
        <p>分页器可以在任何地方使用，但其主要用途是在控制面板中。请参阅usePager钩子，以便操作控制面板的分页器。</p>
    </div>
    
    <div class="code-block">
        <pre><code>&lt;Pager offset="0" limit="80" total="50" onUpdate="doSomething" /&gt;</code></pre>
    </div>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>offset</td>
            <td>number</td>
            <td>页面第一个元素的索引。它从0开始，但分页器显示offset + 1。</td>
        </tr>
        <tr>
            <td>limit</td>
            <td>number</td>
            <td>页面大小。offset和limit的总和对应于页面最后一个元素的索引。</td>
        </tr>
        <tr>
            <td>total</td>
            <td>number</td>
            <td>页面可以达到的元素总数。</td>
        </tr>
        <tr>
            <td>onUpdate</td>
            <td>function</td>
            <td>当分页器修改页面时调用的函数。此函数可以是异步的，当此函数执行时分页器无法编辑。</td>
        </tr>
        <tr>
            <td>isEditable</td>
            <td>boolean</td>
            <td>允许点击当前页面进行编辑（默认为true）。</td>
        </tr>
        <tr>
            <td>withAccessKey</td>
            <td>boolean</td>
            <td>在上一页按钮上绑定访问键p，在下一页按钮上绑定n（默认为true）。</td>
        </tr>
    </table>
    
    <h3 id="frontend-select-menu">SelectMenu</h3>
    <h4>位置</h4>
    <p><code>@web/core/select_menu/select_menu</code></p>
    
    <h4>描述</h4>
    <p>当您想要做的不仅仅是使用原生<code>select</code>元素时，可以使用此组件。您可以定义自己的选项模板，允许在选项之间搜索，或将它们分组在子部分中。</p>
    
    <div class="note">
        <p>优先选择原生HTML <code>select</code>元素，因为它默认提供可访问性功能，并在移动设备上具有更好的用户界面。此组件旨在用于更复杂的用例，以克服原生元素的限制。</p>
    </div>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>choices</td>
            <td>array</td>
            <td>可选。要在下拉菜单中显示的选项列表。</td>
        </tr>
        <tr>
            <td>class</td>
            <td>string</td>
            <td>可选。设置在SelectMenu组件根部的类名。</td>
        </tr>
        <tr>
            <td>groups</td>
            <td>array</td>
            <td>可选。包含要在下拉菜单中显示的选项的组列表。</td>
        </tr>
        <tr>
            <td>multiSelect</td>
            <td>boolean</td>
            <td>可选。启用多选。启用多选后，选定的值显示为SelectMenu输入中的<a href="#frontend-tags-list">标签</a>。</td>
        </tr>
        <tr>
            <td>togglerClass</td>
            <td>string</td>
            <td>可选。设置在切换按钮上的类名。</td>
        </tr>
        <tr>
            <td>required</td>
            <td>boolean</td>
            <td>可选。选定的值是否可以取消选择。</td>
        </tr>
        <tr>
            <td>searchable</td>
            <td>boolean</td>
            <td>可选。下拉菜单中是否可见搜索框。</td>
        </tr>
        <tr>
            <td>searchPlaceholder</td>
            <td>string</td>
            <td>可选。显示为搜索框占位符的文本。</td>
        </tr>
        <tr>
            <td>value</td>
            <td>any</td>
            <td>可选。当前选定的值。可以是任何类型。</td>
        </tr>
        <tr>
            <td>onSelect</td>
            <td>function</td>
            <td>可选。选择选项时执行的回调。</td>
        </tr>
    </table>
    
    <p><code>choice</code>的形状如下：</p>
    <ul>
        <li><code>value</code>是选项的实际值。通常是技术字符串，但可以是<code>any</code>类型。</li>
        <li><code>label</code>是与选项关联的显示文本。这通常是更友好和翻译的<code>string</code>。</li>
    </ul>
    
    <p><code>group</code>的形状如下：</p>
    <ul>
        <li><code>choices</code>是要为此组显示的<code>choice</code>列表。</li>
        <li><code>label</code>是与组关联的显示文本。这是一个显示在组顶部的<code>string</code>。</li>
    </ul>
    
    <p>示例</p>
    <p>在以下示例中，SelectMenu将显示四个选项。其中一个显示在选项顶部，因为没有与之关联的组，但其他选项由其组的标签分隔。</p>
    
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { SelectMenu } from "@web/core/select_menu/select_menu";

class MyComponent extends Component {
  static template = xml`
    &lt;SelectMenu
      choices="choices"
      groups="groups"
      value="'value_2'"
    /&gt;
  `;

  get choices() {
    return [
        {
          value: "value_1",
          label: "第一个值"
        }
    ]
  }
  get groups() {
    return [
      {
          label: "组A",
          choices: [
              {
                value: "value_2",
                label: "第二个值"
              },
              {
                value: "value_3",
                label: "第三个值"
              }
          ]
      },
      {
          label: "组B",
          choices: [
              {
                value: "value_4",
                label: "第四个值"
              }
          ]
      }
    ]
  }
}</code></pre>
    </div>
    
    <p>您还可以使用适当的组件<code>slot</code>自定义切换器的外观并为选项设置自定义模板。</p>
    
    <div class="code-block">
        <pre><code>&lt;SelectMenu
  choices="choices"
  groups="groups"
  value="'value_2'"
&gt;
  做个选择！
  &lt;t t-set-slot="choice" t-slot-scope="choice"&gt;
    &lt;span class="coolClass" t-esc="'👉 ' + choice.data.label + ' 👈'" /&gt;
  &lt;/t&gt;
&lt;/SelectMenu&gt;</code></pre>
    </div>
    
    <div class="image-example">
        <div class="image-title">SelectMenu使用和自定义示例</div>
    </div>
    
    <p>当SelectMenu用于多选时，<code>value</code> props必须是一个<code>Array</code>，包含选定选项的值。</p>
    
    <div class="image-example">
        <div class="image-title">用于多选的SelectMenu示例</div>
    </div>
    
    <p>对于更高级的用例，您可以使用<code>bottomArea</code>插槽自定义下拉菜单的底部区域。在这里，我们选择显示一个按钮，其中包含在搜索输入中设置的相应值。</p>
    
    <div class="code-block">
        <pre><code>&lt;SelectMenu
    choices="choices"
&gt;
    &lt;span class="select_menu_test"&gt;选择一些内容&lt;/span&gt;
    &lt;t t-set-slot="bottomArea" t-slot-scope="select"&gt;
        &lt;div t-if="select.data.searchValue"&gt;
            &lt;button class="btn text-primary" t-on-click="() => this.onCreate(select.data.searchValue)"&gt;
                创建这篇文章"&lt;i t-esc="select.data.searchValue" /&gt;"
            &lt;/button&gt;
        &lt;/div&gt;
    &lt;/t&gt;
&lt;/SelectMenu&gt;</code></pre>
    </div>
    
    <div class="image-example">
        <div class="image-title">SelectMenu底部区域自定义示例</div>
    </div>
    
    <h3 id="frontend-tags-list">TagsList</h3>
    <h4>位置</h4>
    <p><code>@web/core/tags_list/tags_list</code></p>
    
    <h4>描述</h4>
    <p>此组件可以在圆形药丸中显示标签列表。这些标签可以简单列出几个值，也可以是可编辑的，允许删除项目。可以使用<code>itemsVisible</code> props限制显示项目的数量。如果列表长度超过此限制，则在最后一个标签旁边的圆圈中显示额外项目的数量。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>displayBadge</td>
            <td>boolean</td>
            <td>可选。标签是否显示为徽章。</td>
        </tr>
        <tr>
            <td>displayText</td>
            <td>boolean</td>
            <td>可选。标签是否显示带有文本。</td>
        </tr>
        <tr>
            <td>itemsVisible</td>
            <td>number</td>
            <td>可选。列表中可见标签的限制。</td>
        </tr>
        <tr>
            <td>tags</td>
            <td>array</td>
            <td>提供给组件的标签元素列表。</td>
        </tr>
    </table>
    
    <p><code>tag</code>的形状如下：</p>
    <ul>
        <li><code>colorIndex</code>是可选的颜色ID。</li>
        <li><code>icon</code>是一个可选图标，显示在显示文本之前。</li>
        <li><code>id</code>是标签的唯一标识符。</li>
        <li><code>img</code>是一个可选图像，显示在圆圈中，就在显示文本之前。</li>
        <li><code>onClick</code>是可以给元素的可选回调。这允许父元素根据点击的标签处理任何功能。</li>
        <li><code>onDelete</code>是可以给元素的可选回调。这使得从标签列表中删除项目成为可能，并且必须由父元素处理。</li>
        <li><code>text</code>是与标签关联的显示<code>string</code>。</li>
    </ul>
    
    <p>示例</p>
    <p>在下一个示例中，使用TagsList组件显示多个标签。开发者需要从父组件处理点击标签时会发生什么，或者点击删除按钮时会发生什么。</p>
    
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { TagsList } from "@web/core/tags_list/tags_list";

class Parent extends Component {
  static template = xml`&lt;TagsList tags="tags" /&gt;`;
  static components = { TagsList };

  setup() {
    this.tags = [{
        id: "tag1",
        text: "地球"
    }, {
        colorIndex: 1,
        id: "tag2",
        text: "风",
        onDelete: () => {...}
    }, {
        colorIndex: 2,
        id: "tag3",
        text: "火",
        onClick: () => {...},
        onDelete: () => {...}
    }];
  }
}</code></pre>
    </div>
    
    <p>根据给每个标签的属性，它们的外观和行为会有所不同。</p>
    
    <div class="image-example">
        <div class="image-title">使用不同props和属性的TagsList示例</div>
    </div>
    
    <h3 id="frontend-dialog">Dialog</h3>
    <h4>位置</h4>
    <p><code>@web/core/dialog/dialog</code></p>
    
    <h4>描述</h4>
    <p>Dialog组件是一个模态对话框，它可以覆盖在页面上，用于显示重要信息或提供用户交互。对话框可以包含任何内容，通常带有标题和关闭按钮。Dialog组件通常与useDialog钩子一起使用，以便以编程方式显示对话框。</p>
    
    <div class="note">
        <p>尽管可以直接使用Dialog组件，但推荐使用useDialog钩子来管理对话框，这样可以更好地控制对话框的生命周期。</p>
    </div>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>title</td>
            <td>string</td>
            <td>对话框的标题</td>
        </tr>
        <tr>
            <td>contentClass</td>
            <td>string</td>
            <td>可选。添加到对话框内容的类名</td>
        </tr>
        <tr>
            <td>size</td>
            <td>string</td>
            <td>可选。对话框的大小，可以是'sm'（小）、'md'（中，默认）、'lg'（大）或'xl'（超大）</td>
        </tr>
        <tr>
            <td>technical</td>
            <td>boolean</td>
            <td>可选。如果为true，对话框将使用技术样式</td>
        </tr>
        <tr>
            <td>fullscreen</td>
            <td>boolean</td>
            <td>可选。如果为true，对话框将覆盖整个屏幕</td>
        </tr>
        <tr>
            <td>backdrop</td>
            <td>boolean</td>
            <td>可选。是否显示背景遮罩</td>
        </tr>
        <tr>
            <td>onClose</td>
            <td>function</td>
            <td>可选。关闭对话框时调用的函数</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { Dialog } from "@web/core/dialog/dialog";
import { useDialog } from "@web/core/dialog/dialog_hook";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;button t-on-click="openDialog"&gt;打开对话框&lt;/button&gt;
    &lt;/div&gt;
  `;
  static components = { Dialog };

  setup() {
    this.dialog = useDialog();
  }

  openDialog() {
    this.dialog.add(MyDialogComponent, {
      title: "重要提示",
      size: "lg",
      onClose: () => console.log("对话框已关闭")
    });
  }
}

class MyDialogComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;p&gt;这是对话框的内容&lt;/p&gt;
      &lt;button t-on-click="close" class="btn btn-primary"&gt;确定&lt;/button&gt;
    &lt;/div&gt;
  `;

  setup() {
    this.close = () => this.props.close();
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-popover">Popover</h3>
    <h4>位置</h4>
    <p><code>@web/core/popover/popover</code></p>
    
    <h4>描述</h4>
    <p>Popover组件用于在点击元素时显示一个弹出框，通常用于显示附加信息或提供上下文操作。与Dialog不同，Popover通常更轻量，并且与特定UI元素关联。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>target</td>
            <td>HTMLElement</td>
            <td>弹出框所附加的目标元素</td>
        </tr>
        <tr>
            <td>position</td>
            <td>string</td>
            <td>可选。弹出框相对于目标元素的位置，例如'bottom'、'top'、'left'、'right'</td>
        </tr>
        <tr>
            <td>onClose</td>
            <td>function</td>
            <td>可选。关闭弹出框时调用的函数</td>
        </tr>
        <tr>
            <td>class</td>
            <td>string</td>
            <td>可选。添加到弹出框的类名</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { Popover } from "@web/core/popover/popover";
import { useRef } from "@odoo/owl";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;button t-ref="button" t-on-click="togglePopover"&gt;显示弹出框&lt;/button&gt;
      &lt;Popover t-if="showPopover" target="buttonRef.el" onClose="() => this.showPopover = false"&gt;
        &lt;div class="p-3"&gt;
          &lt;p&gt;这是弹出框的内容&lt;/p&gt;
          &lt;button t-on-click="() => this.showPopover = false" class="btn btn-sm btn-primary"&gt;关闭&lt;/button&gt;
        &lt;/div&gt;
      &lt;/Popover&gt;
    &lt;/div&gt;
  `;
  static components = { Popover };

  setup() {
    this.buttonRef = useRef("button");
    this.showPopover = false;
  }

  togglePopover() {
    this.showPopover = !this.showPopover;
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-datepicker">DatePicker</h3>
    <h4>位置</h4>
    <p><code>@web/core/datepicker/datepicker</code></p>
    
    <h4>描述</h4>
    <p>DatePicker组件提供了一个用户友好的界面来选择日期。它显示一个日历，允许用户浏览并选择日期，支持多种日期格式和本地化。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>date</td>
            <td>string/Date</td>
            <td>当前选择的日期</td>
        </tr>
        <tr>
            <td>onDateTimeChanged</td>
            <td>function</td>
            <td>日期更改时调用的函数</td>
        </tr>
        <tr>
            <td>format</td>
            <td>string</td>
            <td>可选。日期显示格式</td>
        </tr>
        <tr>
            <td>min</td>
            <td>string/Date</td>
            <td>可选。可选择的最小日期</td>
        </tr>
        <tr>
            <td>max</td>
            <td>string/Date</td>
            <td>可选。可选择的最大日期</td>
        </tr>
        <tr>
            <td>placeholder</td>
            <td>string</td>
            <td>可选。输入框中的占位符文本</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { DatePicker } from "@web/core/datepicker/datepicker";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;DatePicker date="state.date" onDateTimeChanged="(date) => this.state.date = date" /&gt;
      &lt;p&gt;选择的日期: &lt;t t-esc="state.date"/&gt;&lt;/p&gt;
    &lt;/div&gt;
  `;
  static components = { DatePicker };

  setup() {
    this.state = useState({
      date: new Date().toISOString().split('T')[0]
    });
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-datetimepicker">DateTimePicker</h3>
    <h4>位置</h4>
    <p><code>@web/core/datepicker/datetimepicker</code></p>
    
    <h4>描述</h4>
    <p>DateTimePicker组件扩展了DatePicker，额外提供了时间选择功能。它可以让用户同时选择日期和时间。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>date</td>
            <td>string/Date</td>
            <td>当前选择的日期和时间</td>
        </tr>
        <tr>
            <td>onDateTimeChanged</td>
            <td>function</td>
            <td>日期或时间更改时调用的函数</td>
        </tr>
        <tr>
            <td>format</td>
            <td>string</td>
            <td>可选。日期和时间显示格式</td>
        </tr>
        <tr>
            <td>min</td>
            <td>string/Date</td>
            <td>可选。可选择的最小日期时间</td>
        </tr>
        <tr>
            <td>max</td>
            <td>string/Date</td>
            <td>可选。可选择的最大日期时间</td>
        </tr>
        <tr>
            <td>placeholder</td>
            <td>string</td>
            <td>可选。输入框中的占位符文本</td>
        </tr>
    </table>
    
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { DateTimePicker } from "@web/core/datepicker/datetimepicker";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;DateTimePicker 
        date="state.dateTime" 
        onDateTimeChanged="(dateTime) => this.state.dateTime = dateTime"
        format="'yyyy-MM-dd HH:mm:ss'" 
      /&gt;
      &lt;p&gt;选择的日期和时间: &lt;t t-esc="state.dateTime"/&gt;&lt;/p&gt;
    &lt;/div&gt;
  `;
  static components = { DateTimePicker };

  setup() {
    this.state = useState({
      dateTime: new Date().toISOString()
    });
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-searchbar">SearchBar</h3>
    <h4>位置</h4>
    <p><code>@web/search/search_bar/search_bar</code></p>
    
    <h4>描述</h4>
    <p>SearchBar组件提供了一个搜索输入框，通常用于在列表或数据集中搜索内容。它支持即时搜索和提交后搜索，并可以与其他筛选器组件结合使用。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>value</td>
            <td>string</td>
            <td>搜索框的当前值</td>
        </tr>
        <tr>
            <td>onSearch</td>
            <td>function</td>
            <td>提交搜索时调用的函数</td>
        </tr>
        <tr>
            <td>placeholder</td>
            <td>string</td>
            <td>可选。搜索框的占位符文本</td>
        </tr>
        <tr>
            <td>autofocus</td>
            <td>boolean</td>
            <td>可选。是否自动聚焦搜索框</td>
        </tr>
        <tr>
            <td>searchDelay</td>
            <td>number</td>
            <td>可选。实时搜索的延迟时间（毫秒）</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { SearchBar } from "@web/search/search_bar/search_bar";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;SearchBar 
        value="state.searchValue" 
        onSearch="(value) => this.search(value)"
        placeholder="'搜索...'" 
        autofocus="true"
      /&gt;
      &lt;div t-if="state.searchResults.length"&gt;
        &lt;p&gt;搜索结果:&lt;/p&gt;
        &lt;ul&gt;
          &lt;t t-foreach="state.searchResults" t-as="result" t-key="result.id"&gt;
            &lt;li t-esc="result.name"/&gt;
          &lt;/t&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `;
  static components = { SearchBar };

  setup() {
    this.state = useState({
      searchValue: "",
      searchResults: []
    });
  }

  search(value) {
    this.state.searchValue = value;
    // 执行搜索操作并更新结果
    this.state.searchResults = this.performSearch(value);
  }

  performSearch(query) {
    // 这里应该是实际的搜索逻辑
    return [
      { id: 1, name: `结果 1 包含 "${query}"` },
      { id: 2, name: `结果 2 包含 "${query}"` }
    ];
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-fileuploader">FileUploader</h3>
    <h4>位置</h4>
    <p><code>@web/core/file_upload/file_uploader</code></p>
    
    <h4>描述</h4>
    <p>FileUploader组件提供了一个用户友好的界面，用于上传一个或多个文件。它支持拖放功能、多文件选择和文件类型限制。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>onUpload</td>
            <td>function</td>
            <td>文件上传时调用的函数</td>
        </tr>
        <tr>
            <td>multiUpload</td>
            <td>boolean</td>
            <td>可选。是否允许选择多个文件</td>
        </tr>
        <tr>
            <td>acceptedFileExtensions</td>
            <td>string</td>
            <td>可选。接受的文件类型，例如 '.jpg,.png,.pdf'</td>
        </tr>
        <tr>
            <td>maxUploadSize</td>
            <td>number</td>
            <td>可选。文件的最大大小（字节）</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { FileUploader } from "@web/core/file_upload/file_uploader";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;h3&gt;上传文件&lt;/h3&gt;
      &lt;FileUploader 
        onUpload="onFileUploaded"
        multiUpload="true"
        acceptedFileExtensions="'.jpg,.png,.pdf'"
        maxUploadSize="10000000"
      /&gt;
      &lt;div t-if="state.uploadedFiles.length"&gt;
        &lt;p&gt;已上传的文件:&lt;/p&gt;
        &lt;ul&gt;
          &lt;t t-foreach="state.uploadedFiles" t-as="file" t-key="file.name"&gt;
            &lt;li&gt;&lt;t t-esc="file.name"/&gt; (&lt;t t-esc="formatSize(file.size)"/&gt;)&lt;/li&gt;
          &lt;/t&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `;
  static components = { FileUploader };

  setup() {
    this.state = useState({
      uploadedFiles: []
    });
  }

  onFileUploaded(files) {
    this.state.uploadedFiles = this.state.uploadedFiles.concat(Array.from(files));
  }

  formatSize(bytes) {
    if (bytes < 1024) {
      return bytes + " B";
    } else if (bytes < 1048576) {
      return (bytes / 1024).toFixed(2) + " KB";
    } else {
      return (bytes / 1048576).toFixed(2) + " MB";
    }
  }
}</code></pre>
    </div>
    
    <h3 id="frontend-portal">Portal</h3>
    <h4>位置</h4>
    <p><code>@web/core/portal/portal</code></p>
    
    <h4>描述</h4>
    <p>Portal组件允许将内容渲染到DOM树中的不同位置，而不是组件层次结构中的自然位置。这对于实现模态对话框、弹出框和工具提示非常有用，这些元素通常需要在DOM树的顶层呈现，以避免溢出和z-index问题。</p>
    
    <h4>Props</h4>
    <table>
        <tr>
            <th>名称</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>target</td>
            <td>HTMLElement</td>
            <td>内容要渲染到的目标DOM元素</td>
        </tr>
    </table>
    
    <h4>示例</h4>
    <div class="code-block">
        <pre><code>import { Component, xml } from "@odoo/owl";
import { Portal } from "@web/core/portal/portal";

class MyComponent extends Component {
  static template = xml`
    &lt;div&gt;
      &lt;button t-on-click="() => this.state.showContent = !this.state.showContent"&gt;
        切换内容
      &lt;/button&gt;
      
      &lt;t t-if="state.showContent"&gt;
        &lt;Portal target="document.body"&gt;
          &lt;div class="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-black bg-opacity-50"&gt;
            &lt;div class="bg-white p-4 rounded shadow"&gt;
              &lt;h3&gt;通过Portal渲染的内容&lt;/h3&gt;
              &lt;p&gt;这个内容被渲染到body元素中，而不是组件的自然位置。&lt;/p&gt;
              &lt;button t-on-click="() => this.state.showContent = false" class="btn btn-primary"&gt;关闭&lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Portal&gt;
      &lt;/t&gt;
    &lt;/div&gt;
  `;
  static components = { Portal };

  setup() {
    this.state = useState({
      showContent: false
    });
  }
}</code></pre>
    </div>
</body>
</html> 